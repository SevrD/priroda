// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: queries.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addAnnouncement = `-- name: AddAnnouncement :one
INSERT INTO announcements (
  tgID, txt, chatID
  ) VALUES (
    $1, $2, $3
  )
RETURNING id
`

type AddAnnouncementParams struct {
	Tgid   pgtype.Int8 `json:"tgid"`
	Txt    pgtype.Text `json:"txt"`
	Chatid pgtype.Int8 `json:"chatid"`
}

func (q *Queries) AddAnnouncement(ctx context.Context, arg AddAnnouncementParams) (int64, error) {
	row := q.db.QueryRow(ctx, addAnnouncement, arg.Tgid, arg.Txt, arg.Chatid)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const addPhoto = `-- name: AddPhoto :exec
UPDATE announcements
SET fileID = $2
WHERE id = $1
`

type AddPhotoParams struct {
	ID     int64       `json:"id"`
	Fileid pgtype.Text `json:"fileid"`
}

func (q *Queries) AddPhoto(ctx context.Context, arg AddPhotoParams) error {
	_, err := q.db.Exec(ctx, addPhoto, arg.ID, arg.Fileid)
	return err
}

const ban = `-- name: Ban :exec
UPDATE users
SET ban = true
WHERE tgID = $1
`

func (q *Queries) Ban(ctx context.Context, tgid pgtype.Int8) error {
	_, err := q.db.Exec(ctx, ban, tgid)
	return err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
  tgID, login, name, createData, chatID
) VALUES (
  $1, $2, $3, $4, $5
) ON CONFLICT (tgID)
DO UPDATE SET login = $2, name = $3, chatID = $5
RETURNING id, tgid, login, name, createdata, phone, chatid, ban
`

type CreateUserParams struct {
	Tgid       pgtype.Int8      `json:"tgid"`
	Login      string           `json:"login"`
	Name       string           `json:"name"`
	Createdata pgtype.Timestamp `json:"createdata"`
	Chatid     pgtype.Int8      `json:"chatid"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Tgid,
		arg.Login,
		arg.Name,
		arg.Createdata,
		arg.Chatid,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Tgid,
		&i.Login,
		&i.Name,
		&i.Createdata,
		&i.Phone,
		&i.Chatid,
		&i.Ban,
	)
	return i, err
}

const getAnnId = `-- name: GetAnnId :one
SELECT annID 
FROM chatStatuses
WHERE tgID = $1
`

func (q *Queries) GetAnnId(ctx context.Context, tgid pgtype.Int8) (pgtype.Int8, error) {
	row := q.db.QueryRow(ctx, getAnnId, tgid)
	var annid pgtype.Int8
	err := row.Scan(&annid)
	return annid, err
}

const getAnnouncement = `-- name: GetAnnouncement :one
SELECT txt, publicID
FROM announcements
WHERE tgID = $1 AND id = $2
`

type GetAnnouncementParams struct {
	Tgid pgtype.Int8 `json:"tgid"`
	ID   int64       `json:"id"`
}

type GetAnnouncementRow struct {
	Txt      pgtype.Text `json:"txt"`
	Publicid pgtype.Int8 `json:"publicid"`
}

func (q *Queries) GetAnnouncement(ctx context.Context, arg GetAnnouncementParams) (GetAnnouncementRow, error) {
	row := q.db.QueryRow(ctx, getAnnouncement, arg.Tgid, arg.ID)
	var i GetAnnouncementRow
	err := row.Scan(&i.Txt, &i.Publicid)
	return i, err
}

const getAnnouncementOnAdmMsgID = `-- name: GetAnnouncementOnAdmMsgID :one
SELECT txt, fileID, chatID, id, tgID, publicID
FROM announcements
WHERE admMsgID = $1
`

type GetAnnouncementOnAdmMsgIDRow struct {
	Txt      pgtype.Text `json:"txt"`
	Fileid   pgtype.Text `json:"fileid"`
	Chatid   pgtype.Int8 `json:"chatid"`
	ID       int64       `json:"id"`
	Tgid     pgtype.Int8 `json:"tgid"`
	Publicid pgtype.Int8 `json:"publicid"`
}

func (q *Queries) GetAnnouncementOnAdmMsgID(ctx context.Context, admmsgid pgtype.Int8) (GetAnnouncementOnAdmMsgIDRow, error) {
	row := q.db.QueryRow(ctx, getAnnouncementOnAdmMsgID, admmsgid)
	var i GetAnnouncementOnAdmMsgIDRow
	err := row.Scan(
		&i.Txt,
		&i.Fileid,
		&i.Chatid,
		&i.ID,
		&i.Tgid,
		&i.Publicid,
	)
	return i, err
}

const getStatus = `-- name: GetStatus :one
SELECT status 
FROM chatStatuses
WHERE tgID = $1
`

func (q *Queries) GetStatus(ctx context.Context, tgid pgtype.Int8) (pgtype.Int8, error) {
	row := q.db.QueryRow(ctx, getStatus, tgid)
	var status pgtype.Int8
	err := row.Scan(&status)
	return status, err
}

const getUserInfo = `-- name: GetUserInfo :one
SELECT login, name, ban 
FROM users
WHERE tgID = $1
`

type GetUserInfoRow struct {
	Login string      `json:"login"`
	Name  string      `json:"name"`
	Ban   pgtype.Bool `json:"ban"`
}

func (q *Queries) GetUserInfo(ctx context.Context, tgid pgtype.Int8) (GetUserInfoRow, error) {
	row := q.db.QueryRow(ctx, getUserInfo, tgid)
	var i GetUserInfoRow
	err := row.Scan(&i.Login, &i.Name, &i.Ban)
	return i, err
}

const setAdminMsgID = `-- name: SetAdminMsgID :exec
UPDATE announcements
SET admMsgId = $1
WHERE id = $2
`

type SetAdminMsgIDParams struct {
	Admmsgid pgtype.Int8 `json:"admmsgid"`
	ID       int64       `json:"id"`
}

func (q *Queries) SetAdminMsgID(ctx context.Context, arg SetAdminMsgIDParams) error {
	_, err := q.db.Exec(ctx, setAdminMsgID, arg.Admmsgid, arg.ID)
	return err
}

const setPublicID = `-- name: SetPublicID :exec
UPDATE announcements
SET publicID = $1
WHERE id = $2
`

type SetPublicIDParams struct {
	Publicid pgtype.Int8 `json:"publicid"`
	ID       int64       `json:"id"`
}

func (q *Queries) SetPublicID(ctx context.Context, arg SetPublicIDParams) error {
	_, err := q.db.Exec(ctx, setPublicID, arg.Publicid, arg.ID)
	return err
}

const setStatus = `-- name: SetStatus :one
INSERT INTO chatStatuses (
  tgID, status, annID
) VALUES (
  $1, $2, $3
) ON CONFLICT (tgID)
DO UPDATE SET status = $2, annID = $3
RETURNING tgid, status, annid
`

type SetStatusParams struct {
	Tgid   pgtype.Int8 `json:"tgid"`
	Status pgtype.Int8 `json:"status"`
	Annid  pgtype.Int8 `json:"annid"`
}

func (q *Queries) SetStatus(ctx context.Context, arg SetStatusParams) (Chatstatus, error) {
	row := q.db.QueryRow(ctx, setStatus, arg.Tgid, arg.Status, arg.Annid)
	var i Chatstatus
	err := row.Scan(&i.Tgid, &i.Status, &i.Annid)
	return i, err
}

const unBan = `-- name: UnBan :exec
UPDATE users
SET ban = false
WHERE tgID = $1
`

func (q *Queries) UnBan(ctx context.Context, tgid pgtype.Int8) error {
	_, err := q.db.Exec(ctx, unBan, tgid)
	return err
}
